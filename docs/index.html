<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VotingPlugin Presets</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 18px; }
    header { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    input, select, button, textarea { padding: 8px 10px; font-size: 14px; }
    textarea { resize: vertical; }
    button { cursor: pointer; }
    .muted { color:#666; }
    .error { color:#b00020; }
    .layout { display:grid; grid-template-columns: 1.1fr 1fr; gap:14px; margin-top:14px; }
    .card { border:1px solid #e6e6e6; border-radius:12px; padding:12px; background:#fff; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; }
    code { background:#f5f5f5; padding:2px 6px; border-radius:6px; }
    pre { background:#0b1020; color:#d6e1ff; padding:12px; border-radius:10px; overflow:auto; max-height:520px; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #eee; padding:8px; text-align:left; vertical-align:top; }
    th { background:#fafafa; position: sticky; top: 0; }
    .split { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .list { max-height:420px; overflow:auto; }
    label { display:flex; flex-direction:column; gap:4px; margin-bottom:10px; }
    .subcard { border:1px solid #eee; border-radius:10px; padding:10px; background:#fcfcfc; margin-top:10px; }
    .hint { font-size:12px; color:#666; margin-top:4px; }
  </style>
</head>

<body>

<header>
  <h2 style="margin:0;">VotingPlugin Presets</h2>

  <button id="reloadBtn">Reload</button>
  <button id="pickFolderBtn" style="display:none;">Pick Folder</button>
  <span id="status" class="muted"></span>
</header>

<div class="row" style="margin-top:10px;">
  <input id="q" size="34" placeholder="Search presets..." />
  <select id="cat">
    <option value="">All</option>
    <option value="votesites">VoteSites</option>
    <option value="rewards">Rewards</option>
    <option value="milestones">VoteMilestones</option>
    <option value="bundles">Bundles</option>
  </select>
  <span class="muted" id="count"></span>
</div>

<div id="msg" class="error" style="margin-top:10px;"></div>

<div class="layout">

  <!-- LEFT -->
  <div class="card">
    <div class="pill">Presets</div>
    <div class="list" style="margin-top:8px;">
      <table>
        <thead>
          <tr>
            <th style="width:30%;">ID</th>
            <th style="width:18%;">Category</th>
            <th>Name</th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </div>
  </div>

  <!-- RIGHT -->
  <div class="card">
    <div class="row" style="justify-content:space-between;">
      <div>
        <div class="pill">Merged YAML</div>
        <div id="selTitle" class="muted" style="margin-top:4px;">None</div>
      </div>
      <button id="copyBtn" disabled>Copy</button>
    </div>

    <hr style="border:none;border-top:1px solid #eee;margin:10px 0;" />

    <div class="split">
      <div>
        <div class="pill">VoteSite placeholders</div>
        <div class="hint">Vote delay options are optional: leave blank to omit the YAML line.</div>
        <div id="votesiteForm" style="margin-top:8px;"></div>
      </div>

      <div>
        <div class="pill">Reward add-ons</div>
        <div class="hint">Rewards merge into <code>VoteSites.&lt;siteKey&gt;.Rewards</code></div>

        <select id="addonRewards" multiple size="7" style="width:100%; margin-top:8px;"></select>

        <div class="pill" style="margin-top:12px;">Reward placeholders</div>
        <div class="hint">Each selected reward has its own placeholders.</div>
        <div id="rewardForms"></div>
      </div>
    </div>

    <!-- silent unless invalid -->
    <div id="yamlStatus" class="error" style="margin-top:10px; display:none;"></div>

    <pre id="mergedOut" style="margin-top:10px;">Select a VoteSite preset.</pre>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

<script>
/* =====================================================
   MODE DETECTION (HTTP vs file://)
   ===================================================== */
const isFileMode = location.protocol === "file:";
let rootDirHandle = null;

/* =====================================================
   DOM
   ===================================================== */
const elRows = document.getElementById("rows");
const elMerged = document.getElementById("mergedOut");
const elCopy = document.getElementById("copyBtn");
const elSelTitle = document.getElementById("selTitle");
const elVoteSiteForm = document.getElementById("votesiteForm");
const elRewardForms = document.getElementById("rewardForms");
const elAddRewards = document.getElementById("addonRewards");
const elQ = document.getElementById("q");
const elCat = document.getElementById("cat");
const elCount = document.getElementById("count");
const elMsg = document.getElementById("msg");
const elStatus = document.getElementById("status");
const elYamlStatus = document.getElementById("yamlStatus");
const elPickFolderBtn = document.getElementById("pickFolderBtn");

/* =====================================================
   YAML VALIDATION (silent unless error)
   ===================================================== */
function clearYamlError() {
  elYamlStatus.textContent = "";
  elYamlStatus.style.display = "none";
}
function showYamlError(msg) {
  elYamlStatus.textContent = msg;
  elYamlStatus.style.display = "block";
}
function shouldValidateYaml(text) {
  const s = String(text || "").trim();
  return s && (s.includes(":") || s.startsWith("- "));
}
function validateYamlText(text) {
  // Never break the app if YAML lib isn't available
  if (!window.jsyaml || typeof window.jsyaml.load !== "function") return true;

  const s = String(text || "").trim();
  if (!shouldValidateYaml(s)) {
    clearYamlError();
    return true;
  }
  try {
    window.jsyaml.load(s);
    clearYamlError();
    return true;
  } catch (err) {
    const line = err?.mark?.line;
    const col = err?.mark?.column;
    const loc =
      Number.isInteger(line) && Number.isInteger(col)
        ? ` (line ${line + 1}, col ${col + 1})`
        : "";
    showYamlError(`Invalid YAML${loc}: ${err.message || String(err)}`);
    return false;
  }
}

/* =====================================================
   LOCAL FILE ACCESS (file:// only)
   ===================================================== */
async function pickRootFolder() {
  if (!window.showDirectoryPicker) {
    throw new Error("Local mode requires Chrome/Edge/Brave (File System Access API).");
  }
  rootDirHandle = await window.showDirectoryPicker();
}

/**
 * Reads a local file relative to the picked root folder.
 *
 * @param {string} path
 * @returns {Promise<string>}
 */
async function readLocalFile(path) {
  const clean = String(path || "").replace(/^\/+/, "").trim();
  if (!clean) throw new Error("Local read failed: empty path");
  if (!rootDirHandle) await pickRootFolder();

  const parts = clean.split("/").filter(Boolean);
  let dir = rootDirHandle;

  for (let i = 0; i < parts.length - 1; i++) {
    const seg = parts[i];
    try {
      dir = await dir.getDirectoryHandle(seg);
    } catch {
      throw new Error(
        `Local read failed: missing directory "${seg}" while resolving "${clean}". ` +
        `Pick the repo root (contains presets/ or bundles/).`
      );
    }
  }

  const fileName = parts[parts.length - 1];
  try {
    const fh = await dir.getFileHandle(fileName);
    const file = await fh.getFile();
    return await file.text();
  } catch {
    throw new Error(
      `Local read failed: missing file "${fileName}" while resolving "${clean}". ` +
      `Pick the repo root (contains presets/ or bundles/).`
    );
  }
}

/* =====================================================
   FETCH ABSTRACTION
   ===================================================== */
async function fetchText(path) {
  if (isFileMode) {
    return readLocalFile(path);
  }
  const r = await fetch(path, { cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status} for ${path}`);
  return r.text();
}

async function fetchJson(path) {
  return JSON.parse(await fetchText(path));
}

/* =====================================================
   HELPERS (from build-index.mjs)
   ===================================================== */
/**
 * @param {any} domains
 * @returns {string[]}
 */
function normalizeDomains(domains) {
  if (!Array.isArray(domains)) return [];
  return domains
    .filter((d) => typeof d === "string" && d.trim().length > 0)
    .map((d) => d.trim().toLowerCase())
    .map((d) => (d.startsWith("www.") ? d.substring(4) : d))
    .filter((d, i, a) => a.indexOf(d) === i)
    .sort();
}

/**
 * @param {any} keywords
 * @returns {string[]}
 */
function normalizeKeywords(keywords) {
  if (!Array.isArray(keywords)) return [];
  return keywords
    .filter((k) => typeof k === "string" && k.trim().length > 0)
    .map((k) => k.trim().toLowerCase())
    .filter((k, i, a) => a.indexOf(k) === i)
    .sort();
}

/**
 * @param {string} metaPath
 * @returns {string}
 */
function inferCategory(metaPath) {
  const p = String(metaPath || "").replaceAll("\\", "/");
  if (p.includes("presets/votesites/")) return "votesites";
  if (p.includes("presets/rewards/")) return "rewards";
  if (p.includes("presets/milestones/")) return "milestones";
  if (p.includes("bundles/")) return "bundles";
  return "other";
}

/**
 * @param {any} meta
 * @param {string} relMetaPath
 * @returns {any}
 */
function toIndexEntry(meta, relMetaPath) {
  const id = meta?.id;
  const name = meta?.display?.name;
  if (typeof id !== "string" || id.trim() === "") {
    throw new Error(`Missing/invalid meta.id in ${relMetaPath}`);
  }
  if (typeof name !== "string" || name.trim() === "") {
    throw new Error(`Missing/invalid display.name in ${relMetaPath}`);
  }

  const description =
    typeof meta?.display?.description === "string" ? meta.display.description : "";

  const domains = normalizeDomains(meta?.match?.domains);
  const keywords = normalizeKeywords(meta?.match?.keywords);

  const updatedAt =
    typeof meta?.updatedAt === "string" && meta.updatedAt.trim() !== ""
      ? meta.updatedAt
      : null;

  const verified = meta?.verified === true;

  return {
    id,
    category: inferCategory(relMetaPath),
    name,
    description,
    keywords,
    domains,
    metaPath: relMetaPath.replaceAll("\\", "/"),
    updatedAt,
    verified,
  };
}

/**
 * @param {any[]} entries
 * @returns {any[]}
 */
function sortEntries(entries) {
  return entries.sort((a, b) => {
    const c = (a.category || "").localeCompare(b.category || "");
    if (c !== 0) return c;
    return (a.id || "").localeCompare(b.id || "");
  });
}

/**
 * Recursively walk directory handles and return paths that match.
 *
 * @param {FileSystemDirectoryHandle} dir
 * @param {(p: string) => boolean} match
 * @param {string} prefix
 * @param {string[]} out
 * @returns {Promise<string[]>}
 */
async function walkFiles(dir, match, prefix = "", out = []) {
  for await (const [name, handle] of dir.entries()) {
    const fullPath = prefix ? `${prefix}/${name}` : name;
    if (handle.kind === "directory") {
      await walkFiles(handle, match, fullPath, out);
    } else if (handle.kind === "file") {
      if (match(fullPath)) out.push(fullPath);
    }
  }
  return out;
}

/**
 * Build index entries in local mode by scanning presets/ and bundles/,
 * emulating tools/build-index.mjs behavior.
 *
 * @returns {Promise<any[]>}
 */
async function buildIndexFromLocalRepo() {
  if (!rootDirHandle) await pickRootFolder();

  let presetsDir = null;
  let bundlesDir = null;

  try { presetsDir = await rootDirHandle.getDirectoryHandle("presets"); } catch {}
  try { bundlesDir = await rootDirHandle.getDirectoryHandle("bundles"); } catch {}

  if (!presetsDir && !bundlesDir) {
    throw new Error("No presets/ or bundles/ folder found. Pick the repo root folder.");
  }

  const metaPaths = [];

  if (presetsDir) {
    const found = await walkFiles(presetsDir, (p) => p.endsWith(".meta.json"), "presets");
    metaPaths.push(...found);
  }
  if (bundlesDir) {
    const found = await walkFiles(bundlesDir, (p) => p.endsWith(".bundle.json"), "bundles");
    metaPaths.push(...found);
  }

  const entries = [];
  const seenIds = new Set();

  for (const relPath of metaPaths) {
    const meta = JSON.parse(await readLocalFile(relPath));

    if (relPath.endsWith(".bundle.json")) {
      const id = meta?.id;
      const name = meta?.display?.name;
      if (typeof id !== "string" || typeof name !== "string") {
        throw new Error(`Bundle missing id/display.name: ${relPath}`);
      }

      const entry = {
        id,
        category: "bundles",
        name,
        description: typeof meta?.display?.description === "string" ? meta.display.description : "",
        keywords: normalizeKeywords(meta?.keywords),
        domains: [],
        metaPath: relPath.replaceAll("\\", "/"),
        updatedAt: typeof meta?.updatedAt === "string" ? meta.updatedAt : null,
        verified: meta?.verified === true,
      };

      if (seenIds.has(entry.id)) throw new Error(`Duplicate id: ${entry.id}`);
      seenIds.add(entry.id);
      entries.push(entry);
      continue;
    }

    const entry = toIndexEntry(meta, relPath);
    if (seenIds.has(entry.id)) throw new Error(`Duplicate id: ${entry.id}`);
    seenIds.add(entry.id);
    entries.push(entry);
  }

  return sortEntries(entries);
}

/* =====================================================
   ORIGINAL APP HELPERS
   ===================================================== */
function norm(s) { return String(s || "").toLowerCase().trim(); }

function toYamlListBlock(multiline, indentSpaces) {
  const pad = " ".repeat(indentSpaces);
  const lines = String(multiline || "")
    .split(/\r?\n/)
    .map(s => s.trim())
    .filter(s => s.length > 0);

  if (!lines.length) return pad + "- \"\"";
  return lines.map(l => `${pad}- "${l.replaceAll('"', '\\"')}"`).join("\n");
}

function applyPlaceholders(text, values) {
  let out = text;
  for (const [k, v] of Object.entries(values)) {
    out = out.split(`<${k}>`).join(String(v));
  }
  return out;
}

/* Minimal fragment parser (maps + lists; enough for our preset fragments) */
function parseFragmentYaml(yaml) {
  const lines = String(yaml || "").replace(/\t/g, "  ").split(/\r?\n/);
  while (lines.length && lines[0].trim() === "") lines.shift();
  while (lines.length && lines[lines.length - 1].trim() === "") lines.pop();

  const root = {};
  const stack = [{ indent: -1, node: root, type: "map" }];

  function current() { return stack[stack.length - 1]; }
  function parseScalar(raw) {
    const s = raw.trim();
    if (s === "true") return true;
    if (s === "false") return false;
    if (/^-?\d+(\.\d+)?$/.test(s)) return Number(s);
    if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) return s.slice(1, -1);
    return s;
  }

  for (let i = 0; i < lines.length; i++) {
    const lineRaw = lines[i];
    if (!lineRaw.trim() || lineRaw.trim().startsWith("#")) continue;

    const indent = lineRaw.match(/^ */)[0].length;
    const line = lineRaw.trim();

    while (stack.length > 1 && indent <= current().indent) stack.pop();
    const ctx = current();

    if (line.startsWith("- ")) {
      if (ctx.type !== "list") continue;
      ctx.node.push(parseScalar(line.substring(2)));
      continue;
    }

    const idx = line.indexOf(":");
    if (idx === -1 || ctx.type !== "map") continue;

    const key = line.substring(0, idx).trim();
    const rest = line.substring(idx + 1).trim();

    if (rest === "") {
      let j = i + 1;
      let next = null;
      while (j < lines.length) {
        const t = lines[j].trim();
        if (t && !t.startsWith("#")) { next = lines[j].trim(); break; }
        j++;
      }
      const nextIsList = next && next.startsWith("- ");
      const child = nextIsList ? [] : {};
      ctx.node[key] = child;
      stack.push({ indent, node: child, type: nextIsList ? "list" : "map" });
    } else {
      ctx.node[key] = parseScalar(rest);
    }
  }
  return root;
}

function deepMerge(target, source) {
  if (Array.isArray(target) && Array.isArray(source)) return target.concat(source);
  if (target && typeof target === "object" && !Array.isArray(target) &&
      source && typeof source === "object" && !Array.isArray(source)) {
    for (const [k, v] of Object.entries(source)) {
      target[k] = (k in target) ? deepMerge(target[k], v) : v;
    }
    return target;
  }
  return source;
}

function mergeIntoPath(rootObj, pathStr, fragmentObj) {
  const parts = pathStr.split(".").filter(p => p.length > 0);
  if (!parts.length) return;

  let cur = rootObj;
  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];
    const last = i === parts.length - 1;

    if (last) {
      cur[p] = (cur[p] == null) ? fragmentObj : deepMerge(cur[p], fragmentObj);
    } else {
      if (cur[p] == null || typeof cur[p] !== "object") cur[p] = {};
      cur = cur[p];
    }
  }
}

function renderYaml(obj, indent = 0) {
  const pad = " ".repeat(indent);
  if (Array.isArray(obj)) {
    return obj.map(v => `${pad}- "${String(v).replaceAll('"','\\"')}"`).join("\n");
  }
  if (obj && typeof obj === "object") {
    return Object.keys(obj).map(k => {
      const v = obj[k];
      if (v && typeof v === "object") {
        return `${pad}${k}:\n${renderYaml(v, indent + 2)}`;
      }
      if (typeof v === "string") return `${pad}${k}: "${v.replaceAll('"','\\"')}"`;
      return `${pad}${k}: ${String(v)}`;
    }).join("\n");
  }
  return `${pad}${String(obj)}`;
}

function buildVoteSiteLinePlaceholders(map) {
  const vd = String(map.voteDelay ?? "").trim();
  map.voteDelayLine = vd ? `VoteDelay: ${vd}` : "";

  const wuvd = String(map.waitUntilVoteDelay ?? "").trim().toLowerCase();
  map.waitUntilVoteDelayLine =
    (wuvd === "true" || wuvd === "false") ? `WaitUntilVoteDelay: ${wuvd}` : "";

  const vdd = String(map.voteDelayDaily ?? "").trim().toLowerCase();
  map.voteDelayDailyLine =
    (vdd === "true" || vdd === "false") ? `VoteDelayDaily: ${vdd}` : "";

  const vddh = String(map.voteDelayDailyHour ?? "").trim();
  map.voteDelayDailyHourLine =
    (/^\d+$/.test(vddh) ? `VoteDelayDailyHour: ${vddh}` : "");
}

async function loadFragments(meta) {
  const frags = Array.isArray(meta.fragments) ? meta.fragments : [];
  const out = [];
  for (const f of frags) {
    if (!f.path || !f.mergeInto) continue;
    out.push({ mergeInto: f.mergeInto, text: await fetchText(f.path) });
  }
  return out;
}

/* =====================================================
   STATE (original)
   ===================================================== */
let indexData = [];
let rewardEntries = [];
let selectedVoteSiteEntry = null;
let selectedVoteSiteMeta = null;

let voteSiteValues = {};
let rewardMetasById = {};
let rewardValuesById = {};

/* =====================================================
   LOAD INDEX (HTTP uses index.json; file:// builds if missing)
   ===================================================== */
async function loadIndex() {
  elMsg.textContent = "";
  elStatus.textContent = isFileMode ? "Local mode" : "Loading...";
  elMerged.textContent = "Loading...";
  elCopy.disabled = true;

  try {
    if (!isFileMode) {
      const idx = await fetchJson("index.json");
      indexData = idx.entries || [];
    } else {
      // file:// mode: try index.json; if missing, emulate build-index.mjs
      try {
        const idx = await fetchJson("index.json");
        indexData = idx.entries || [];
      } catch {
        elStatus.textContent = "Local mode: building index from presets/ + bundles/ ...";
        indexData = await buildIndexFromLocalRepo();
      }
    }

    rewardEntries = indexData.filter(e => e.category === "rewards");

    renderIndex();
    elStatus.textContent = `Loaded ${indexData.length} presets`;
    elMerged.textContent = "Select a VoteSite preset.";
    clearYamlError();
  } catch (e) {
    elStatus.textContent = "";
    elMsg.textContent = e.message || String(e);
    elMerged.textContent = "Failed to load presets.";
    elCopy.disabled = true;
  }
}

function filteredEntries() {
  const q = norm(elQ.value);
  const c = norm(elCat.value);

  let list = indexData.slice();
  if (c) list = list.filter(e => norm(e.category) === c);

  if (q) {
    list = list.filter(e => {
      const hay = [
        e.id, e.category, e.name, e.description,
        ...(e.keywords || []),
        ...(e.domains || [])
      ].map(norm).join(" ");
      return hay.includes(q);
    });
  }

  elCount.textContent = `${list.length} shown / ${indexData.length} total`;
  return list;
}

function renderIndex() {
  const list = filteredEntries();
  elRows.innerHTML = list.map(e => `
    <tr data-id="${e.id}">
      <td><code>${e.id}</code></td>
      <td>${e.category}</td>
      <td>${e.name}</td>
    </tr>
  `).join("");

  elRows.querySelectorAll("tr").forEach(tr => {
    tr.onclick = () => selectPreset(tr.dataset.id);
  });
}

/* =====================================================
   SELECTION
   ===================================================== */
async function selectPreset(id) {
  const entry = indexData.find(e => e.id === id);
  if (!entry) return;

  if (entry.category !== "votesites") {
    elMerged.textContent = "Please select a VoteSites preset (rewards are add-ons).";
    return;
  }

  selectedVoteSiteEntry = entry;
  elSelTitle.textContent = `${entry.name} (${entry.id})`;
  elMerged.textContent = "Loading VoteSite preset...";
  elCopy.disabled = true;

  rewardMetasById = {};
  rewardValuesById = {};
  elRewardForms.innerHTML = "";

  elAddRewards.innerHTML = rewardEntries.map(e => `<option value="${e.id}">${e.name}</option>`).join("");
  elAddRewards.onchange = onRewardsChanged;

  try {
    selectedVoteSiteMeta = await fetchJson(entry.metaPath);
    buildVoteSiteForm();
    await rebuild();
  } catch (e) {
    elMerged.textContent = "Failed to load preset: " + (e.message || String(e));
  }
}

function buildVoteSiteForm() {
  const ph = selectedVoteSiteMeta.placeholders || {};
  voteSiteValues = {};
  elVoteSiteForm.innerHTML = "";

  for (const [k, spec] of Object.entries(ph)) {
    const el = document.createElement("input");
    el.value = spec.default ?? "";
    voteSiteValues[k] = el.value;

    el.oninput = () => {
      voteSiteValues[k] = el.value;
      rebuild();
    };

    const wrap = document.createElement("label");
    wrap.innerHTML = `<strong>${spec.label || k}</strong>`;
    wrap.appendChild(el);
    elVoteSiteForm.appendChild(wrap);
  }
}

async function onRewardsChanged() {
  elRewardForms.innerHTML = "";

  for (const opt of elAddRewards.selectedOptions) {
    const rewardId = opt.value;
    const entry = rewardEntries.find(r => r.id === rewardId);
    if (!entry) continue;

    if (!rewardMetasById[rewardId]) {
      rewardMetasById[rewardId] = await fetchJson(entry.metaPath);
    }

    if (!rewardValuesById[rewardId]) {
      rewardValuesById[rewardId] = {};
      const ph = rewardMetasById[rewardId].placeholders || {};
      for (const [k, spec] of Object.entries(ph)) {
        rewardValuesById[rewardId][k] = spec.default ?? "";
      }
    }

    renderRewardForm(rewardId, entry.name, rewardMetasById[rewardId]);
  }

  await rebuild();
}

function renderRewardForm(rewardId, displayName, meta) {
  const ph = meta.placeholders || {};
  const container = document.createElement("div");
  container.className = "subcard";

  container.innerHTML = `
    <div>
      <strong>${displayName}</strong>
      <div class="muted" style="font-size:12px;">${rewardId}</div>
    </div>
  `;

  for (const [k, spec] of Object.entries(ph)) {
    const isMultiline = (k === "commands" || k === "messages");
    const el = document.createElement(isMultiline ? "textarea" : "input");
    el.value = rewardValuesById[rewardId][k] ?? "";
    if (isMultiline) el.rows = 4;

    el.oninput = () => {
      rewardValuesById[rewardId][k] = el.value;
      rebuild();
    };

    const wrap = document.createElement("label");
    wrap.innerHTML = `<strong>${spec.label || k}</strong>`;
    wrap.appendChild(el);
    container.appendChild(wrap);
  }

  elRewardForms.appendChild(container);
}

/* =====================================================
   MERGE BUILD
   ===================================================== */
async function rebuild() {
  if (!selectedVoteSiteMeta) return;

  elMerged.textContent = "Building merged YAML...";
  elCopy.disabled = true;

  const tree = {};

  try {
    // 1) Merge VoteSite fragments into VoteSites
    const voteSiteDerived = { ...voteSiteValues };
    buildVoteSiteLinePlaceholders(voteSiteDerived);

    const voteSiteFrags = await loadFragments(selectedVoteSiteMeta);
    for (const f of voteSiteFrags) {
      const mergeInto = applyPlaceholders(f.mergeInto, voteSiteDerived).trim();
      if (!mergeInto.startsWith("VoteSites")) continue;

      const text = applyPlaceholders(f.text, voteSiteDerived).trim();
      const obj = parseFragmentYaml(text);
      mergeIntoPath(tree, mergeInto, obj);
    }

    // 2) Merge reward add-ons into VoteSites.<siteKey>.Rewards
    const baseMap = { ...voteSiteDerived };

    for (const opt of elAddRewards.selectedOptions) {
      const rewardId = opt.value;
      const meta = rewardMetasById[rewardId];
      if (!meta) continue;

      const frags = await loadFragments(meta);

      const rewardVals = rewardValuesById[rewardId] || {};
      const rewardDerived = { ...rewardVals };

      if (rewardDerived.commands != null) rewardDerived.commandsBlock = toYamlListBlock(rewardDerived.commands, 2);
      if (rewardDerived.messages != null) rewardDerived.messagesBlock = toYamlListBlock(rewardDerived.messages, 2);

      const mergedMap = { ...baseMap, ...rewardDerived };

      for (const f of frags) {
        const mergeInto = applyPlaceholders(f.mergeInto, mergedMap).trim();
        if (!mergeInto.startsWith("VoteSites")) continue;

        const text = applyPlaceholders(f.text, mergedMap).trim();
        const obj = parseFragmentYaml(text);
        mergeIntoPath(tree, mergeInto, obj);
      }
    }

    const out = renderYaml(tree, 0);
    elMerged.textContent = out ? (out.trimEnd() + "\n") : "Nothing to output.";

    let valid = true;
    try {
      valid = validateYamlText(elMerged.textContent);
    } catch {
      valid = true;
      clearYamlError();
    }
    elCopy.disabled = !valid;

  } catch (e) {
    elMerged.textContent = "Failed to build YAML: " + (e.message || String(e));
    showYamlError("YAML validation skipped: failed to build output");
    elCopy.disabled = true;
  }
}

/* =====================================================
   EVENTS
   ===================================================== */
document.getElementById("reloadBtn").onclick = loadIndex;
elQ.addEventListener("input", renderIndex);
elCat.addEventListener("change", renderIndex);

elCopy.onclick = async () => {
  try {
    await navigator.clipboard.writeText(elMerged.textContent);
    elCopy.textContent = "Copied!";
    setTimeout(() => elCopy.textContent = "Copy", 900);
  } catch {
    const ta = document.createElement("textarea");
    ta.value = elMerged.textContent;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    elCopy.textContent = "Copied!";
    setTimeout(() => elCopy.textContent = "Copy", 900);
  }
};

/* =====================================================
   LOCAL MODE BUTTON
   ===================================================== */
if (elPickFolderBtn) {
  elPickFolderBtn.style.display = isFileMode ? "inline-block" : "none";
  elPickFolderBtn.onclick = async () => {
    try {
      rootDirHandle = null;
      await pickRootFolder();
      await loadIndex();
    } catch (e) {
      elMsg.textContent = e.message || String(e);
    }
  };
}

loadIndex();
</script>

</body>
</html>
