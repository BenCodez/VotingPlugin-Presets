<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VotingPlugin Presets</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 18px; }
    header { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    input, select, button, textarea { padding: 8px 10px; font-size: 14px; }
    textarea { resize: vertical; }
    button { cursor: pointer; }
    .muted { color:#666; }
    .error { color:#b00020; }
    .layout { display:grid; grid-template-columns: 1.1fr 1fr; gap:14px; margin-top:14px; }
    .card { border:1px solid #e6e6e6; border-radius:12px; padding:12px; background:#fff; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; }
    code { background:#f5f5f5; padding:2px 6px; border-radius:6px; }
    pre { background:#0b1020; color:#d6e1ff; padding:12px; border-radius:10px; overflow:auto; max-height:520px; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #eee; padding:8px; text-align:left; vertical-align:top; }
    th { background:#fafafa; position: sticky; top: 0; }
    .split { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .list { max-height:420px; overflow:auto; }
    label { display:flex; flex-direction:column; gap:4px; margin-bottom:10px; }
    .subcard { border:1px solid #eee; border-radius:10px; padding:10px; background:#fcfcfc; margin-top:10px; }
  </style>
</head>

<body>

<header>
  <h2 style="margin:0;">VotingPlugin Presets</h2>

  <label class="small">
    <span class="muted">Registry base URL</span>
    <input id="baseUrl" size="48" />
  </label>

  <button id="reloadBtn">Reload</button>
  <span id="status" class="muted"></span>
</header>

<div class="row" style="margin-top:10px;">
  <input id="q" size="34" placeholder="Search presets..." />
  <select id="cat">
    <option value="">All</option>
    <option value="votesites">VoteSites</option>
    <option value="rewards">Rewards</option>
    <option value="milestones">VoteMilestones</option>
  </select>
  <span class="muted" id="count"></span>
</div>

<div id="msg" class="error" style="margin-top:10px;"></div>

<div class="layout">

  <!-- LEFT -->
  <div class="card">
    <div class="pill">Presets</div>
    <div class="list" style="margin-top:8px;">
      <table>
        <thead>
          <tr>
            <th style="width:30%;">ID</th>
            <th style="width:18%;">Category</th>
            <th>Name</th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </div>
  </div>

  <!-- RIGHT -->
  <div class="card">
    <div class="row" style="justify-content:space-between;">
      <div>
        <div class="pill">Merged YAML</div>
        <div id="selTitle" class="muted" style="margin-top:4px;">None</div>
      </div>
      <button id="copyBtn" disabled>Copy</button>
    </div>

    <hr style="border:none;border-top:1px solid #eee;margin:10px 0;" />

    <div class="split">
      <div>
        <div class="pill">VoteSite placeholders</div>
        <div id="votesiteForm" style="margin-top:8px;"></div>
      </div>

      <div>
        <div class="pill">Reward add-ons</div>
        <div class="muted" style="font-size:12px; margin-top:6px;">
          Reward fragments merge into <code>VoteSites.&lt;siteKey&gt;.Rewards</code>
        </div>
        <select id="addonRewards" multiple size="7" style="width:100%; margin-top:8px;"></select>

        <div class="pill" style="margin-top:12px;">Reward placeholders</div>
        <div id="rewardForms"></div>
      </div>
    </div>

    <pre id="mergedOut" style="margin-top:10px;">Select a VoteSite preset.</pre>
  </div>

</div>

<script>
/* ---------------- helpers ---------------- */
function normalizeBaseUrl(url) {
  let u = (url || "").trim();
  if (!u.endsWith("/")) u += "/";
  return u;
}
function norm(s) { return String(s || "").toLowerCase().trim(); }

function toYamlListBlock(multiline, indentSpaces) {
  const pad = " ".repeat(indentSpaces);
  const lines = String(multiline || "")
    .split(/\r?\n/)
    .map(s => s.trim())
    .filter(s => s.length > 0);

  if (!lines.length) return pad + "- \"\"";
  return lines.map(l => `${pad}- "${l.replaceAll('"', '\\"')}"`).join("\n");
}

function applyPlaceholders(text, values) {
  let out = text;
  for (const [k, v] of Object.entries(values)) {
    out = out.split(`<${k}>`).join(String(v));
  }
  return out;
}

/* Minimal fragment parser (maps + lists) */
function parseFragmentYaml(yaml) {
  const lines = String(yaml || "").replace(/\t/g, "  ").split(/\r?\n/);
  while (lines.length && lines[0].trim() === "") lines.shift();
  while (lines.length && lines[lines.length - 1].trim() === "") lines.pop();

  const root = {};
  const stack = [{ indent: -1, node: root, type: "map" }];

  function current() { return stack[stack.length - 1]; }
  function parseScalar(raw) {
    const s = raw.trim();
    if (s === "true") return true;
    if (s === "false") return false;
    if (/^-?\d+(\.\d+)?$/.test(s)) return Number(s);
    // keep quoted values as string content
    if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
      return s.slice(1, -1);
    }
    return s;
  }

  for (let i = 0; i < lines.length; i++) {
    const lineRaw = lines[i];
    if (!lineRaw.trim() || lineRaw.trim().startsWith("#")) continue;

    const indent = lineRaw.match(/^ */)[0].length;
    const line = lineRaw.trim();

    while (stack.length > 1 && indent <= current().indent) stack.pop();
    const ctx = current();

    if (line.startsWith("- ")) {
      if (ctx.type !== "list") {
        // should not happen in our fragments if well-formed; ignore
        continue;
      }
      ctx.node.push(parseScalar(line.substring(2)));
      continue;
    }

    const idx = line.indexOf(":");
    if (idx === -1 || ctx.type !== "map") continue;

    const key = line.substring(0, idx).trim();
    const rest = line.substring(idx + 1).trim();

    if (rest === "") {
      // determine if next is list
      let j = i + 1;
      let next = null;
      while (j < lines.length) {
        const t = lines[j].trim();
        if (t && !t.startsWith("#")) { next = lines[j].trim(); break; }
        j++;
      }
      const nextIsList = next && next.startsWith("- ");
      const child = nextIsList ? [] : {};
      ctx.node[key] = child;
      stack.push({ indent, node: child, type: nextIsList ? "list" : "map" });
    } else {
      ctx.node[key] = parseScalar(rest);
    }
  }
  return root;
}

function deepMerge(target, source) {
  if (Array.isArray(target) && Array.isArray(source)) return target.concat(source);
  if (target && typeof target === "object" && !Array.isArray(target) &&
      source && typeof source === "object" && !Array.isArray(source)) {
    for (const [k, v] of Object.entries(source)) {
      target[k] = (k in target) ? deepMerge(target[k], v) : v;
    }
    return target;
  }
  return source;
}

function mergeIntoPath(rootObj, pathStr, fragmentObj) {
  const parts = pathStr.split(".").filter(p => p.length > 0);
  if (!parts.length) return;

  let cur = rootObj;
  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];
    const last = i === parts.length - 1;

    if (last) {
      cur[p] = (cur[p] == null) ? fragmentObj : deepMerge(cur[p], fragmentObj);
    } else {
      if (cur[p] == null || typeof cur[p] !== "object") cur[p] = {};
      cur = cur[p];
    }
  }
}

function renderYaml(obj, indent = 0) {
  const pad = " ".repeat(indent);
  if (Array.isArray(obj)) {
    return obj.map(v => `${pad}- "${String(v).replaceAll('"','\\"')}"`).join("\n");
  }
  if (obj && typeof obj === "object") {
    return Object.keys(obj).map(k => {
      const v = obj[k];
      if (v && typeof v === "object") {
        return `${pad}${k}:\n${renderYaml(v, indent + 2)}`;
      }
      if (typeof v === "string") return `${pad}${k}: "${v.replaceAll('"','\\"')}"`;
      return `${pad}${k}: ${String(v)}`;
    }).join("\n");
  }
  return `${pad}${String(obj)}`;
}

/* ---------------- state ---------------- */
let indexData = [];
let rewardEntries = [];
let selectedVoteSiteEntry = null;
let selectedVoteSiteMeta = null;

let voteSiteValues = {};                 // placeholders for votesite
let rewardMetasById = {};                // cache meta per reward id
let rewardValuesById = {};               // placeholder values per reward id

const elBase = document.getElementById("baseUrl");
const elRows = document.getElementById("rows");
const elMerged = document.getElementById("mergedOut");
const elCopy = document.getElementById("copyBtn");
const elSelTitle = document.getElementById("selTitle");
const elVoteSiteForm = document.getElementById("votesiteForm");
const elRewardForms = document.getElementById("rewardForms");
const elAddRewards = document.getElementById("addonRewards");
const elQ = document.getElementById("q");
const elCat = document.getElementById("cat");
const elCount = document.getElementById("count");
const elMsg = document.getElementById("msg");
const elStatus = document.getElementById("status");

/* ---------------- init base URL ---------------- */
(function initBase() {
  elBase.value = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, "/");
})();

/* ---------------- fetch helpers ---------------- */
async function fetchJson(url) {
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
  return await r.json();
}
async function fetchText(url) {
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
  return await r.text();
}
async function loadFragments(meta) {
  const base = normalizeBaseUrl(elBase.value);
  const frags = Array.isArray(meta.fragments) ? meta.fragments : [];
  const out = [];
  for (const f of frags) {
    if (!f.path || !f.mergeInto) continue;
    out.push({ mergeInto: f.mergeInto, text: await fetchText(base + f.path) });
  }
  return out;
}

/* ---------------- load index ---------------- */
async function loadIndex() {
  elMsg.textContent = "";
  elStatus.textContent = "Loading...";
  elMerged.textContent = "Loading...";
  elCopy.disabled = true;

  const base = normalizeBaseUrl(elBase.value);

  try {
    const idx = await fetchJson(base + "index.json");
    indexData = idx.entries || [];
    rewardEntries = indexData.filter(e => e.category === "rewards");

    renderIndex();
    elStatus.textContent = `Loaded ${indexData.length} presets`;
    elMerged.textContent = "Select a VoteSite preset.";
  } catch (e) {
    elStatus.textContent = "";
    elMsg.textContent = e.message || String(e);
    elMerged.textContent = "Failed to load index.";
  }
}

function filteredEntries() {
  const q = norm(elQ.value);
  const c = norm(elCat.value);

  let list = indexData.slice();
  if (c) list = list.filter(e => norm(e.category) === c);

  if (q) {
    list = list.filter(e => {
      const hay = [
        e.id, e.category, e.name, e.description,
        ...(e.keywords || []),
        ...(e.domains || [])
      ].map(norm).join(" ");
      return hay.includes(q);
    });
  }
  elCount.textContent = `${list.length} shown / ${indexData.length} total`;
  return list;
}

function renderIndex() {
  const list = filteredEntries();
  elRows.innerHTML = list.map(e => `
    <tr data-id="${e.id}">
      <td><code>${e.id}</code></td>
      <td>${e.category}</td>
      <td>${e.name}</td>
    </tr>
  `).join("");

  elRows.querySelectorAll("tr").forEach(tr => {
    tr.onclick = () => selectPreset(tr.dataset.id);
  });
}

/* ---------------- selection ---------------- */
async function selectPreset(id) {
  const base = normalizeBaseUrl(elBase.value);
  const entry = indexData.find(e => e.id === id);
  if (!entry) return;

  if (entry.category !== "votesites") {
    elMerged.textContent = "Please select a VoteSites preset (rewards are add-ons).";
    return;
  }

  selectedVoteSiteEntry = entry;
  elSelTitle.textContent = `${entry.name} (${entry.id})`;
  elMerged.textContent = "Loading VoteSite preset...";
  elCopy.disabled = true;

  rewardMetasById = {};
  rewardValuesById = {};
  elRewardForms.innerHTML = "";
  elAddRewards.innerHTML = rewardEntries.map(e => `<option value="${e.id}">${e.name}</option>`).join("");

  try {
    selectedVoteSiteMeta = await fetchJson(base + entry.metaPath);
    buildVoteSiteForm();
    elAddRewards.onchange = onRewardsChanged;
    await rebuild();
  } catch (e) {
    elMerged.textContent = "Failed to load preset: " + (e.message || String(e));
  }
}

function buildVoteSiteForm() {
  const ph = selectedVoteSiteMeta.placeholders || {};
  voteSiteValues = {};
  elVoteSiteForm.innerHTML = "";

  for (const [k, spec] of Object.entries(ph)) {
    const el = document.createElement("input");
    el.value = spec.default ?? "";
    voteSiteValues[k] = el.value;

    el.oninput = () => {
      voteSiteValues[k] = el.value;
      rebuild();
    };

    const wrap = document.createElement("label");
    wrap.innerHTML = `<strong>${spec.label || k}</strong>`;
    wrap.appendChild(el);
    elVoteSiteForm.appendChild(wrap);
  }
}

async function onRewardsChanged() {
  // Load metas for selected rewards and build placeholder editors for each.
  const base = normalizeBaseUrl(elBase.value);
  elRewardForms.innerHTML = "";

  for (const opt of elAddRewards.selectedOptions) {
    const rewardId = opt.value;
    const entry = rewardEntries.find(r => r.id === rewardId);
    if (!entry) continue;

    if (!rewardMetasById[rewardId]) {
      rewardMetasById[rewardId] = await fetchJson(base + entry.metaPath);
    }

    if (!rewardValuesById[rewardId]) {
      // init defaults
      rewardValuesById[rewardId] = {};
      const ph = rewardMetasById[rewardId].placeholders || {};
      for (const [k, spec] of Object.entries(ph)) {
        rewardValuesById[rewardId][k] = spec.default ?? "";
      }
    }

    renderRewardForm(rewardId, entry.name, rewardMetasById[rewardId]);
  }

  await rebuild();
}

function renderRewardForm(rewardId, displayName, meta) {
  const ph = meta.placeholders || {};
  const container = document.createElement("div");
  container.className = "subcard";

  container.innerHTML = `<div class="row" style="justify-content:space-between;">
    <div><strong>${displayName}</strong><div class="muted" style="font-size:12px;">${rewardId}</div></div>
  </div>`;

  for (const [k, spec] of Object.entries(ph)) {
    const isMultiline = (k === "commands" || k === "messages");
    const el = document.createElement(isMultiline ? "textarea" : "input");
    el.value = rewardValuesById[rewardId][k] ?? "";
    if (isMultiline) el.rows = 4;

    el.oninput = () => {
      rewardValuesById[rewardId][k] = el.value;
      rebuild();
    };

    const wrap = document.createElement("label");
    wrap.innerHTML = `<strong>${spec.label || k}</strong>`;
    wrap.appendChild(el);
    container.appendChild(wrap);
  }

  elRewardForms.appendChild(container);
}

/* ---------------- merge build ---------------- */
async function rebuild() {
  if (!selectedVoteSiteMeta) return;

  elMerged.textContent = "Building merged YAML...";
  elCopy.disabled = true;

  const tree = {};
  try {
    // 1) Merge VoteSite fragments into VoteSites
    const voteSiteDerived = { ...voteSiteValues };
    const voteSiteFrags = await loadFragments(selectedVoteSiteMeta);

    for (const f of voteSiteFrags) {
      const mergeInto = applyPlaceholders(f.mergeInto, voteSiteDerived).trim();
      if (!mergeInto.startsWith("VoteSites")) continue;

      const text = applyPlaceholders(f.text, voteSiteDerived).trim();
      const obj = parseFragmentYaml(text);
      mergeIntoPath(tree, mergeInto, obj);
    }

    // 2) Merge reward add-ons into VoteSites.<siteKey>.Rewards with EACH reward's placeholders
    const baseMap = { ...voteSiteDerived }; // ensures <siteKey> works in mergeInto

    for (const opt of elAddRewards.selectedOptions) {
      const rewardId = opt.value;
      const meta = rewardMetasById[rewardId];
      if (!meta) continue;

      const frags = await loadFragments(meta);

      // Build derived placeholders for this reward preset
      const rewardVals = rewardValuesById[rewardId] || {};
      const rewardDerived = { ...rewardVals };

      if (rewardDerived.commands != null) rewardDerived.commandsBlock = toYamlListBlock(rewardDerived.commands, 2);
      if (rewardDerived.messages != null) rewardDerived.messagesBlock = toYamlListBlock(rewardDerived.messages, 2);

      // Apply placeholders using voteSite map + reward map + derived blocks
      const mergedMap = { ...baseMap, ...rewardDerived };

      for (const f of frags) {
        const mergeInto = applyPlaceholders(f.mergeInto, mergedMap).trim();
        if (!mergeInto.startsWith("VoteSites")) continue;

        const text = applyPlaceholders(f.text, mergedMap).trim();
        const obj = parseFragmentYaml(text);
        mergeIntoPath(tree, mergeInto, obj);
      }
    }

    const out = renderYaml(tree, 0);
    elMerged.textContent = out ? (out.trimEnd() + "\n") : "Nothing to output.";
    elCopy.disabled = false;

  } catch (e) {
    elMerged.textContent = "Failed to build YAML: " + (e.message || String(e));
  }
}

/* ---------------- events ---------------- */
document.getElementById("reloadBtn").onclick = loadIndex;
elQ.addEventListener("input", renderIndex);
elCat.addEventListener("change", renderIndex);

elCopy.onclick = async () => {
  try {
    await navigator.clipboard.writeText(elMerged.textContent);
    elCopy.textContent = "Copied!";
    setTimeout(() => elCopy.textContent = "Copy", 900);
  } catch {
    const ta = document.createElement("textarea");
    ta.value = elMerged.textContent;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    elCopy.textContent = "Copied!";
    setTimeout(() => elCopy.textContent = "Copy", 900);
  }
};

loadIndex();
</script>

</body>
</html>
