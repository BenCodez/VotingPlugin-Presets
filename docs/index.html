<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VotingPlugin Presets</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 18px; }
    header { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    input, select, button, textarea { padding: 8px 10px; font-size: 14px; }
    textarea { resize: vertical; width: 100%; min-height: 58px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    button { cursor: pointer; }
    .muted { color:#666; }
    .error { color:#b00020; white-space:pre-wrap; }
    .layout { display:grid; grid-template-columns: 1.1fr 1fr; gap:14px; margin-top:14px; }
    .card { border:1px solid #e6e6e6; border-radius:12px; padding:12px; background:#fff; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; }
    pre { background:#0b1020; color:#d6e1ff; padding:12px; border-radius:10px; overflow:auto; max-height:520px; white-space:pre; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #eee; padding:8px; text-align:left; vertical-align:top; }
    th { background:#fafafa; position: sticky; top: 0; }
    .split { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .list { max-height:420px; overflow:auto; }
    label { display:flex; flex-direction:column; gap:4px; margin-bottom:10px; }
    .hint { font-size:12px; color:#666; margin-top:4px; }
    .small { font-size:12px; }
  </style>
</head>
<body>

<header>
  <h2 style="margin:0;">VotingPlugin Presets</h2>
  <button id="pickFolderBtn" onclick="onPickFolderClick(event)">Pick Folder</button>
  <button id="reloadBtn">Reload</button>
  <span id="status" class="muted"></span>
</header>

<div class="row" style="margin-top:10px;">
  <input id="q" size="34" placeholder="Search presets..." />
  <select id="cat">
    <option value="">All</option>
    <option value="votesites">VoteSites</option>
    <option value="rewards">Rewards</option>
    <option value="votemilestones">VoteMilestones</option>
    <option value="bundles">Bundles</option>
  </select>
  <span class="muted" id="count"></span>
</div>

<div id="msg" class="error" style="margin-top:10px;"></div>

<div class="layout">

  <div class="card">
    <div class="pill">Presets</div>
    <div class="list" style="margin-top:8px;">
      <table>
        <thead>
          <tr>
            <th style="width:32%;">ID</th>
            <th style="width:18%;">Category</th>
            <th>Name</th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between;">
      <div>
        <div class="pill">Merged YAML</div>
        <div id="selTitle" class="muted small" style="margin-top:4px;">None</div>
      </div>
      <button id="copyBtn" disabled>Copy</button>
    </div>

    <hr style="border:none;border-top:1px solid #eee;margin:10px 0;" />

    <div class="split">
      <div>
        <div class="pill">Preset placeholders</div>
        <div id="baseForm" style="margin-top:8px;"></div>
      </div>

      <div>
        <div class="pill">Reward add-ons</div>
        <div class="hint" id="rewardHint">Pick a base preset first.</div>
        <select id="addonRewards" multiple size="7" style="width:100%; margin-top:8px;"></select>
        <div id="rewardForms"></div>
      </div>
    </div>

    <pre id="mergedOut" style="margin-top:10px;">Pick a folder, then select a preset.</pre>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

<script>
/**
 * Global root directory handle for local mode.
 * Kept on window so it survives if code reloads.
 */
window.rootDirHandle = window.rootDirHandle || null;

/** @type {FileSystemDirectoryHandle|null} */
let rootDirHandle = window.rootDirHandle || null;

const isFileMode = location.protocol === "file:";

const elRows = document.getElementById("rows");
const elMerged = document.getElementById("mergedOut");
const elCopy = document.getElementById("copyBtn");
const elSelTitle = document.getElementById("selTitle");
const elForm = document.getElementById("baseForm");
const elAddRewards = document.getElementById("addonRewards");
const elRewardForms = document.getElementById("rewardForms");
const elMsg = document.getElementById("msg");
const elStatus = document.getElementById("status");
const elCount = document.getElementById("count");
const elQ = document.getElementById("q");
const elCat = document.getElementById("cat");
const elRewardHint = document.getElementById("rewardHint");

let indexData = [];
let rewardEntries = [];

let selectedEntry = null;
let selectedMeta = null;

/** meta cache by id */
const metaById = {};
/** reward meta cache */
const rewardMetaById = {};
/** per-id placeholder values */
let baseValues = {};
let rewardValuesById = {};

/**
 * Pick folder click handler (inline onclick).
 * @param {Event} ev
 */
async function onPickFolderClick(ev) {
  try {
    ev.preventDefault();
    if (!window.showDirectoryPicker) {
      throw new Error("showDirectoryPicker() is not available in this browser/context.");
    }
    const handle = await window.showDirectoryPicker();
    if (!handle) return;
    window.rootDirHandle = handle;
    rootDirHandle = handle;
    elMsg.textContent = "";
    await loadIndex();
  } catch (e) {
    console.error(e);
    elMsg.textContent = (e && e.message) ? e.message : String(e);
  }
}

/**
 * Read a file as text in local mode.
 * @param {string} relPath
 * @returns {Promise<string>}
 */
async function readLocalText(relPath) {
  if (!rootDirHandle) throw new Error("No folder selected.");
  const parts = relPath.split("/").filter(Boolean);
  let dir = rootDirHandle;
  for (let i = 0; i < parts.length - 1; i++) {
    dir = await dir.getDirectoryHandle(parts[i]);
  }
  const fh = await dir.getFileHandle(parts[parts.length - 1]);
  return await (await fh.getFile()).text();
}

/**
 * Fetch text either from local folder or HTTP.
 * @param {string} relPath
 * @returns {Promise<string>}
 */
async function fetchText(relPath) {
  if (isFileMode) return await readLocalText(relPath);
  const r = await fetch(relPath);
  if (!r.ok) throw new Error("Failed to fetch " + relPath + " (" + r.status + ")");
  return await r.text();
}

/**
 * Fetch json either from local folder or HTTP.
 * @param {string} relPath
 * @returns {Promise<any>}
 */
async function fetchJson(relPath) {
  const t = await fetchText(relPath);
  return JSON.parse(t);
}

/**
 * Recursively scan for *.meta.json under presets/.
 * @param {FileSystemDirectoryHandle} dirHandle
 * @param {string} relPrefix
 * @returns {Promise<{path:string, category:string}[]>}
 */
async function scanMetaFiles(dirHandle, relPrefix) {
  const out = [];
  for await (const [name, handle] of dirHandle.entries()) {
    if (handle.kind === "file") {
      if (name.endsWith(".meta.json")) {
        // category is first segment after presets/
        const relPath = relPrefix + name;
        const after = relPath.replace(/^presets\//, "");
        const cat = after.split("/")[0] || "unknown";
        out.push({ path: relPath, category: cat });
      }
    } else if (handle.kind === "directory") {
      // skip hidden folders
      if (name.startsWith(".")) continue;
      out.push(...await scanMetaFiles(handle, relPrefix + name + "/"));
    }
  }
  return out;
}

/**
 * Load index list. In local mode, scans presets/**.meta.json (no index.json needed).
 */
async function loadIndex() {
  elMsg.textContent = "";
  elStatus.textContent = isFileMode ? "Local mode" : "Loading...";
  indexData = [];
  rewardEntries = [];
  Object.keys(metaById).forEach(k => delete metaById[k]);
  Object.keys(rewardMetaById).forEach(k => delete rewardMetaById[k]);

  if (isFileMode) {
    if (!rootDirHandle) {
      elStatus.textContent = "Local mode (pick a folder)";
      renderIndex();
      return;
    }
    // Expect the picked folder to be the project root containing "presets/"
    let presetsDir;
    try {
      presetsDir = await rootDirHandle.getDirectoryHandle("presets");
    } catch {
      throw new Error('Could not find a "presets" folder in the selected directory. Pick the folder that contains presets/.');
    }
    const metas = await scanMetaFiles(presetsDir, "presets/");
    for (const m of metas) {
      const meta = await fetchJson(m.path);
      const name = meta?.display?.name || meta?.id || m.path;
      const entry = {
        id: meta.id,
        name,
        category: m.category,
        metaPath: m.path
      };
      indexData.push(entry);
      metaById[entry.id] = meta;
      if (m.category === "rewards") {
        rewardEntries.push(entry);
        rewardMetaById[entry.id] = meta;
      }
    }
  } else {
    // HTTP mode: still expects index.json
    const idx = await fetchJson("index.json");
    indexData = idx.entries || [];
    for (const e of indexData) {
      const meta = await fetchJson(e.metaPath);
      metaById[e.id] = meta;
      if (e.category === "rewards") {
        rewardEntries.push(e);
        rewardMetaById[e.id] = meta;
      }
    }
  }

  indexData.sort((a,b) => (a.category+a.name).localeCompare(b.category+b.name));
  rewardEntries.sort((a,b) => a.name.localeCompare(b.name));

  elStatus.textContent = isFileMode ? `Local mode (${indexData.length} presets)` : `Loaded (${indexData.length} presets)`;
  renderIndex();
}

/**
 * Render list filtered.
 */
function renderIndex() {
  const q = (elQ.value || "").trim().toLowerCase();
  const cat = elCat.value || "";
  const rows = indexData.filter(e => {
    if (cat && e.category !== cat) return false;
    if (!q) return true;
    return (e.id || "").toLowerCase().includes(q) || (e.name || "").toLowerCase().includes(q);
  });

  elCount.textContent = `${rows.length} shown / ${indexData.length} total`;
  elRows.innerHTML = rows.map(e => `
    <tr style="cursor:pointer;" onclick="selectPreset('${escapeHtml(e.id)}')">
      <td>${escapeHtml(e.id)}</td>
      <td>${escapeHtml(e.category)}</td>
      <td>${escapeHtml(e.name)}</td>
    </tr>
  `).join("");

  if (rows.length === 0) {
    elRows.innerHTML = `<tr><td colspan="3" class="muted">No presets found.</td></tr>`;
  }
}

function escapeHtml(s) {
  return String(s ?? "").replace(/[&<>"']/g, (c) => ({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
  }[c]));
}

/**
 * Build placeholder form for a meta.
 * @param {HTMLElement} container
 * @param {Object} placeholders
 * @param {Object} valuesObj
 * @param {Function} onChange
 */
function buildForm(container, placeholders, valuesObj, onChange) {
  container.innerHTML = "";
  if (!placeholders || Object.keys(placeholders).length === 0) {
    container.innerHTML = `<div class="muted small">No placeholders.</div>`;
    return;
  }

  for (const [key, def] of Object.entries(placeholders)) {
    const lab = document.createElement("label");
    lab.innerHTML = `<strong>${escapeHtml(def.label || key)}</strong>`;

    const type = String(def.type || "").toLowerCase();
    const isTriggerType = key === "triggerType";

    // ENUM dropdown support
    const enumValues = Array.isArray(def.values) ? def.values : (isTriggerType ? ["AT", "EVERY"] : null);
    if ((type === "enum" && enumValues && enumValues.length) || (isTriggerType && enumValues)) {
      const sel = document.createElement("select");
      sel.dataset.key = key;

      // Populate options
      for (const v of enumValues) {
        const opt = document.createElement("option");
        opt.value = String(v);
        opt.textContent = String(v);
        sel.appendChild(opt);
      }

      const current = valuesObj[key] ?? def.default ?? (enumValues[0] ?? "");
      if (valuesObj[key] == null) valuesObj[key] = current;
      sel.value = String(valuesObj[key]);

      sel.addEventListener("change", () => {
        valuesObj[key] = sel.value;
        onChange();
      });

      lab.appendChild(sel);
      container.appendChild(lab);
      continue;
    }

    // Default: textarea
    const ta = document.createElement("textarea");
    ta.value = valuesObj[key] ?? def.default ?? "";
    ta.dataset.key = key;

    // Persist defaults so rebuild() sees them even before the user types.
    if (valuesObj[key] == null) {
      valuesObj[key] = ta.value;
    }

    ta.addEventListener("input", () => {
      valuesObj[key] = ta.value;
      onChange();
    });

    lab.appendChild(ta);
    container.appendChild(lab);
  }
}

async function selectPreset(id) {
  const entry = indexData.find(e => e.id === id);
  if (!entry) return;

  selectedEntry = entry;
  selectedMeta = metaById[id] || await fetchJson(entry.metaPath);

  elSelTitle.textContent = `${entry.name} (${entry.id})`;
  elMerged.textContent = "Building...";
  elCopy.disabled = true;

  baseValues = {};
  rewardValuesById = {};
  elRewardForms.innerHTML = "";

  buildForm(elForm, selectedMeta.placeholders || {}, baseValues, rebuild);

  // Enable rewards for votesites + votemilestones
  const rewardsSupported = entry.category === "votesites" || entry.category === "votemilestones";
  elAddRewards.disabled = !rewardsSupported;
  elAddRewards.innerHTML = rewardEntries.map(e => `<option value="${escapeHtml(e.id)}">${escapeHtml(e.name)}</option>`).join("");
  elAddRewards.onchange = () => {
    rebuildRewardForms();
    rebuild();
  };

  elRewardHint.textContent = rewardsSupported
    ? (entry.category === "votemilestones"
        ? "Rewards merge into VoteMilestones.<milestoneId>.Rewards"
        : "Rewards merge into VoteSites.<siteKey>.Rewards")
    : "Rewards not supported for this preset type.";

  rebuildRewardForms();
  await rebuild();
}

function rebuildRewardForms() {
  elRewardForms.innerHTML = "";
  for (const opt of elAddRewards.selectedOptions) {
    const rid = opt.value;
    const meta = rewardMetaById[rid];
    if (!meta) continue;
    rewardValuesById[rid] = rewardValuesById[rid] || {};
    const box = document.createElement("div");
    box.style.border = "1px solid #eee";
    box.style.borderRadius = "10px";
    box.style.padding = "10px";
    box.style.marginTop = "10px";
    box.innerHTML = `<div class="small muted" style="margin-bottom:6px;"><strong>${escapeHtml(meta.display?.name || rid)}</strong></div>`;
    const inner = document.createElement("div");
    buildForm(inner, meta.placeholders || {}, rewardValuesById[rid], rebuild);
    box.appendChild(inner);
    elRewardForms.appendChild(box);
  }
}

/**
 * Parses YAML fragment; returns {} if blank.
 * @param {string} yml
 */

/**
 * Converts a multiline textarea (one per line) into an indented YAML list block.
 * Example (indent=2):
 *   - "line1"
 *   - "line2"
 *
 * @param {string} raw multiline string
 * @param {number} indent number of spaces before '-'
 * @returns {string} YAML lines or empty string
 */
function toYamlListBlock(raw, indent) {
  const pad = " ".repeat(Math.max(0, indent || 0));
  const lines = String(raw ?? "")
    .split(/\r?\n/)
    .map(s => s.trim())
    .filter(Boolean);

  if (lines.length === 0) return "";

  // Quote each line to avoid YAML edge cases (colons, leading symbols, etc.)
  return lines.map(l => `${pad}- ${JSON.stringify(l)}`).join("\n");
}

function parseFragmentYaml(yml) {
  const t = String(yml || "").trim();
  if (!t) return {};
  const obj = jsyaml.load(t) || {};
  // Clean up common null sections caused by empty placeholders.
  if (obj && typeof obj === 'object') {
    if (Object.prototype.hasOwnProperty.call(obj, 'Commands') && obj.Commands == null) delete obj.Commands;
    if (Object.prototype.hasOwnProperty.call(obj, 'Messages') && obj.Messages == null) delete obj.Messages;
  }
  return obj;
}

/**
 * Deep merge (objects only).
 */
function deepMerge(a, b) {
  if (!a) a = {};
  for (const k of Object.keys(b || {})) {
    const bv = b[k];
    if (bv && typeof bv === "object" && !Array.isArray(bv)) {
      a[k] = deepMerge(a[k] || {}, bv);
    } else {
      a[k] = bv;
    }
  }
  return a;
}

/**
 * Merge obj into tree at dot path.
 * @param {any} tree
 * @param {string} path
 * @param {any} obj
 */
function mergeIntoPath(tree, path, obj) {
  const parts = path.split(".").filter(Boolean);
  let cur = tree;
  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];
    if (i === parts.length - 1) {
      cur[p] = deepMerge(cur[p] || {}, obj);
    } else {
      cur[p] = cur[p] || {};
      cur = cur[p];
    }
  }
}

/**
 * Apply placeholders (<key>) into text.
 * Indent-safe for multiline values.
 */
function applyPlaceholders(text, values) {
  let out = String(text ?? "");

  for (const [k, raw] of Object.entries(values || {})) {
    const token = `<${k}>`;
    if (!out.includes(token)) continue;

    const v = String(raw ?? "");

    if (!v.includes("\n")) {
      // Simple global replacement for single-line values (works for mergeInto paths too).
      out = out.split(token).join(v);
      continue;
    }

    // Indent-aware replacement for multiline values (YAML blocks).
    const reToken = new RegExp(`(^[\\t ]*)${token.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&")}`, "gm");
    out = out.replace(reToken, (match, indent) => {
      const lines = v.split(/\r?\n/);
      const first = lines[0];
      const rest = lines.slice(1).map(l => (l.length ? indent + l : l));
      return indent + [first, ...rest].join("\n");
    });
  }

  // Remove leftover placeholder-only lines
  out = out.replace(/^[ \t]*<[^>\n]+>[ \t]*\r?\n/gm, "");
  return out;
}

/**
 * Helpers for structured VoteMilestones
 */
function parseBool(s) {
  const v = String(s ?? "").trim().toLowerCase();
  if (v === "true" || v === "yes" || v === "1") return true;
  if (v === "false" || v === "no" || v === "0") return false;
  return false;
}
function parseLineList(s) {
  return String(s ?? "")
    .split(/\r?\n/)
    .map(x => x.trim())
    .filter(Boolean);
}
function buildStructuredMilestone(vals) {
  const id = String(vals.milestoneId ?? "").trim();
  if (!id) throw new Error("milestoneId is required");

  const obj = {};
  obj.Enabled = parseBool(vals.enabled);
  obj.Total = String(vals.total ?? "").trim();

  const triggerType = String(vals.triggerType ?? "AT").trim().toUpperCase();
  if (triggerType === "EVERY") {
    const n = Number(String(vals.every ?? "").trim());
    if (!Number.isFinite(n) || n <= 0) throw new Error("Every must be a positive number");
    obj.Every = n;
  } else {
    const at = parseLineList(vals.atList);
    if (at.length === 0) throw new Error("At list must have at least one value");
    obj.At = at;
  }

  const group = String(vals.group ?? "").trim();
  if (group) obj.Group = group;

  const limitType = String(vals.limitType ?? "NONE").trim().toUpperCase();
  if (limitType && limitType !== "NONE") {
    obj.Limit = { Type: limitType };
    if (limitType === "COOLDOWN") {
      const dur = String(vals.limitDuration ?? "").trim();
      if (dur) obj.Limit.Duration = dur;
    }
  }
  return { id, obj };
}

/**
 * Load fragments for a meta (reads file path for each fragment).
 * @param {any} meta
 * @returns {Promise<{mergeInto:string, text:string}[]>}
 */
async function loadFragments(meta) {
  const frags = [];
  for (const f of (meta.fragments || [])) {
    const txt = await fetchText(f.path);
    frags.push({ mergeInto: f.mergeInto, text: txt });
  }
  return frags;
}

/**
 * Rebuild merged YAML.
 */
async function rebuild() {
  if (!selectedEntry || !selectedMeta) return;

  elMsg.textContent = "";
  elCopy.disabled = true;

  try {
    const tree = {};

    const isStructuredMilestone =
      selectedEntry.category === "votemilestones"
      && selectedMeta.type === "votemilestone_structured";

    // 1) Base preset
    if (isStructuredMilestone) {
      const ms = buildStructuredMilestone(baseValues);
      tree.VoteMilestones = tree.VoteMilestones || {};
      tree.VoteMilestones[ms.id] = deepMerge(tree.VoteMilestones[ms.id] || {}, ms.obj);
    } else {
      const frags = await loadFragments(selectedMeta);
      for (const f of frags) {
        const mergeInto = applyPlaceholders(f.mergeInto, baseValues).trim();
        const rendered = applyPlaceholders(f.text, baseValues);
        const obj = parseFragmentYaml(rendered);
        mergeIntoPath(tree, mergeInto, obj);
      }
    }

    // 2) Rewards add-ons
    for (const opt of elAddRewards.selectedOptions) {
      const rid = opt.value;
      const meta = rewardMetaById[rid];
      if (!meta) continue;

      const rVals = rewardValuesById[rid] || {};
      const derived = { ...rVals };
      // Common reward presets use <commandsBlock> / <messagesBlock> placeholders.
      if (derived.commands != null) derived.commandsBlock = toYamlListBlock(derived.commands, 2);
      if (derived.messages != null) derived.messagesBlock = toYamlListBlock(derived.messages, 2);
      const mergedVals = { ...baseValues, ...derived };

      const frags = await loadFragments(meta);
      for (const f of frags) {
        let mergeInto = applyPlaceholders(f.mergeInto, mergedVals).trim();
        if (selectedEntry.category === "votemilestones") {
          mergeInto = applyPlaceholders("VoteMilestones.<milestoneId>.Rewards", mergedVals).trim();
        }
        const rendered = applyPlaceholders(f.text, mergedVals);
        const obj = parseFragmentYaml(rendered);
        mergeIntoPath(tree, mergeInto, obj);
      }
    }

    const out = jsyaml.dump(tree, { lineWidth: 120 });
    elMerged.textContent = out ? (out.trimEnd() + "\n") : "Nothing to output.";
    elCopy.disabled = false;
  } catch (e) {
    console.error(e);
    elMsg.textContent = (e && e.message) ? e.message : String(e);
    elMerged.textContent = "Error building YAML.";
  }
}

document.getElementById("reloadBtn").addEventListener("click", () => loadIndex());
elQ.addEventListener("input", renderIndex);
elCat.addEventListener("change", renderIndex);

elCopy.addEventListener("click", async () => {
  try {
    await navigator.clipboard.writeText(elMerged.textContent || "");
    elStatus.textContent = "Copied!";
    setTimeout(() => { elStatus.textContent = isFileMode ? "Local mode" : ""; }, 1200);
  } catch (e) {
    elMsg.textContent = "Copy failed: " + (e && e.message ? e.message : String(e));
  }
});

// Auto-load in HTTP mode; in file mode you need to pick folder.
if (!isFileMode) loadIndex();
</script>

</body>
</html>